<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minimal SIWE + SMS OTP</title>
  <style>
    body {
      font-family: system-ui, Arial, sans-serif;
      margin: 2rem;
    }

    button {
      margin: 0.5rem 0;
      padding: 0.4rem 0.8rem;
    }

    input {
      padding: 0.4rem;
    }

    #status {
      margin-top: 1rem;
      white-space: pre-line;
      background: #f4f4f4;
      padding: 1rem;
      border-radius: 8px;
    }
  </style>
</head>

<body>
  <h1>Sign‚ÄëIn With Ethereum + SMS OTP</h1>

  <section>
    <button id="connect">1Ô∏è‚É£ Connect MetaMask</button><br />
    <button id="signin" disabled>2Ô∏è‚É£ Sign‚ÄëIn with Ethereum</button>
  </section>

  <section style="margin-top:1rem;">
    <input id="phone" placeholder="+15555550123" />
    <button id="send" disabled>3Ô∏è‚É£ Send SMS OTP</button><br />
    <input id="code" placeholder="Enter OTP" />
    <button id="verify" disabled>4Ô∏è‚É£ Verify OTP</button>
  </section>

  <section style="margin-top:1rem;">
    <button id="logout" disabled>Logout</button>
    <button id="check-session">Check Session Status</button>
  </section>

  <section style="margin-top:1rem;">
    <button id="download_raw_data" disabled>Download Raw data</button>
    <button id="download_aqua_data" disabled>Download Aqua tree</button>
  </section>

  <pre id="status">Status:
- Wallet: (not connected)
- SIWE: (not signed in)
- Phone: (not verified)</pre>

  <script type="module">
    import { ethers } from 'https://esm.sh/ethers@6?bundle';
    import { SiweMessage } from 'https://esm.sh/siwe@3?bundle';
    import axios from 'https://esm.sh/axios@1?bundle';
    import { wrapper } from 'https://esm.sh/axios-cookiejar-support@6?bundle';
    import { CookieJar } from 'https://esm.sh/tough-cookie@5?bundle';
    import Aquafier from 'https://esm.sh/aqua-js-sdk@3.2.1-41';

    (async () => {
      const provider = new ethers.BrowserProvider(window.ethereum);
      let signer, address, chainId;

      const $ = (id) => document.getElementById(id);
      const status = $('status');
      const append = (msg) => (status.textContent += "\n" + msg);
      const api = wrapper(axios.create({ baseURL: 'http://localhost:3000', withCredentials: true, jar: new CookieJar() }));

      // Check session status on page load
      checkSessionStatus();

      async function checkSessionStatus() {
        try {
          const { data } = await api.get('/session-status');
          if (data.authenticated) {
            append(`üîë Already authenticated as ${data.address}`);
            append(`üì± Phone status: ${data.phoneVerified ? `Verified (${data.phone})` : 'Not verified'}`);
            append(`‚è±Ô∏è Session expires at: ${data.expiresAt}`);

            // Enable appropriate buttons
            $('send').disabled = false;
            $('logout').disabled = false;

            if (data.phoneVerified) {
              // If phone is verified, fetch /me data with 'web' platform
              try {
                const { data: me } = await api.get('/me?platform=web');
                append('üë§ /me data available');

                // Check if AquaTree needs client-side signing
                if (!me.signed && me.platform === 'web') {
                  append('üîë AquaTree needs to be signed with MetaMask');
                }
              } catch (err) {
                append('‚ùå Error fetching /me data');
              }
            } else {
              // If not verified, enable verification
              $('verify').disabled = false;
            }
          } else {
            append('Not authenticated. Please connect wallet and sign in.');
          }
        } catch (err) {
          console.error('Error checking session:', err);
        }
      }

      $('connect').onclick = async () => {
        try {
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          signer = await provider.getSigner();
          address = await signer.getAddress();
          chainId = (await provider.getNetwork()).chainId;
          append('‚úÖ Wallet connected: ' + address);
          $('signin').disabled = false;
        } catch (err) {
          alert(err.message || err);
        }
      };

      $('signin').onclick = async () => {
        try {
          const { data: nonce } = await api.get('/nonce');
          const msgObj = new SiweMessage({
            domain: 'localhost',
            address,
            statement: 'Sign in with Ethereum (Twilio Verify OTP)',
            uri: 'http://localhost:3000',
            version: '1',
            chainId,
            nonce,
          });
          const message = msgObj.prepareMessage();
          const signature = await signer.signMessage(message);
          const res = await api.post('/verify', { message, signature });
          if (!res.data.ok) throw new Error(JSON.stringify(res));
          append('‚úÖ SIWE verified for ' + res.data.address);
          $('send').disabled = false;
          $('logout').disabled = false;

          // Check session status after login
          await checkSessionStatus();
        } catch (err) {
          alert(err.message || err);
        }
      };

      $('send').onclick = async () => {
        try {
          const phone = $('phone').value.trim();
          const res = await api.post('/sms-request', { phone });

          if (!res.data.ok) throw new Error(res.data.error || 'SMS request failed');
          append('üì≤ OTP sent to ' + phone);
          $('verify').disabled = false;
        } catch (err) {
          alert(err.message || err);
        }
      };

      let aquaTreeDataForDownload = null;
      let rawDataForDownload = null;
      $('verify').onclick = async () => {
        try {
          const code = $('code').value.trim();
          const res = await api.post('/sms-verify', { code });
          if (!res.data.ok) throw new Error(res.data.error || 'Verification failed');
          append('‚úÖ Phone verified: ' + res.data.phone);

          // Fetch protected data after verification with 'web' platform
          try {
            const { data } = await api.get('/me?platform=web');
            append('üë§ /me data received');



            // Check if AquaTree needs client-side signing
            if (!data.signed && data.platform === 'web') {

              append(`üîÜ  Attestation Payload: ${data.aquaTree}`);
              append('üîë AquaTree needs to be signed with MetaMask');
              console.log(`Aqua tree ${JSON.stringify(data.aquaTree)} needs to be signed fileObject ${JSON.stringify(data.fileObject)}`);
              let aquaTree = data.aquaTree
              let fileObject = data.fileObject
              let aquafier = new Aquafier()
              const aquaTreeWrapper = {
                aquaTree: aquaTree,
                revision: "",
                fileObject: fileObject
              }
              const creds = {
                mnemonic: "",
                nostr_sk: "",
                did_key: "",
                alchemy_key: "",
                witness_eth_network: "sepolia",
                witness_method: "metamask",
                // p12 config
                p12_password: "",
                p12_content: "",
              }
              let aquaTreeSignedRes = await aquafier.signAquaTree(aquaTreeWrapper, "metamask", creds, true);

              if(aquaTreeSignedRes.isErr()) {
                append(`‚ùå Error signing AquaTree: ${JSON.stringify(aquaTreeSignedRes.data, null, 2)}`);
                return;
              }

              let aquaTreeSigned =aquaTreeSignedRes.data.aquaTree

              console.log("Aquatreesigned: ", aquaTreeSigned)
              const dataJson = JSON.parse(aquaTreeSigned, null, 2);

              append(`‚ñ∂Ô∏è  aquaTree: ${dataJson}`);
              // Here you would typically implement the client-side signing logic
              // using the user's connected MetaMask wallet

              $('download_raw_data').disabled = false;
              $('download_aqua_data').disabled = false;

               $('signin').disabled = true;
               $('send').disabled = true;
              $('connect').disabled = true;

              rawDataForDownload = JSON.stringify(aquaTree, null, 2);
              aquaTreeDataForDownload = JSON.stringify(dataJson, null, 2);


            }
          } catch (err) {
            console.log(err)
            append('‚ùå Error fetching /me data: ' + (err.response?.data?.error || err.message));
          }
        } catch (err) {
          alert(err.message || err);
        }
      };

      $('logout').onclick = async () => {
        try {
          await api.post('/logout');
          append('üîì Logged out successfully');
          $('signin').disabled = true;
          $('send').disabled = true;
          $('verify').disabled = true;
          $('logout').disabled = true;
          $('download_raw_data').disabled = true;
          $('download_aqua_data').disabled = true;

          // Check session status after logout
          await checkSessionStatus();
        } catch (err) {
          alert(err.message || err);
        }
      };

      $('check-session').onclick = async () => {
        status.textContent = 'Status:\n';
        await checkSessionStatus();
      };

      // Download AquaTree data as data.json
      $('download_aqua_data').onclick = () => {
        if (!aquaTreeDataForDownload) {
          alert('No AquaTree data available for download.');
          return;
        }
        const blob = new Blob([aquaTreeDataForDownload], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'data.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };


      // Download AquaTree data as data.json
      $('download_raw_data').onclick = () => {
        if (!rawDataForDownload) {
          alert('No raw data available for download.');
          return;
        }
        const blob = new Blob([rawDataForDownload], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'data.aqua.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };
    })();
  </script>
</body>

</html>